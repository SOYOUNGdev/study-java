1. 조건문
 1-1. 조건문이란?
	무조건 실행되는 것이 아니라, 특정조건을 충족할 경우에만 실행되는 구문

 1-2. 조건문의 종류
	if문
	if~else문
	if~else if~else문
	switch문

 1-3. if문
    -문법
    -if문은 주어진 조건이 참일 경우에 지정된 구문이 실행된다.
    
	if(조건) { 

	}

    -if문의 조건식
	-> 비교식(비교 연산자 사용)
	-> 논리식(논리 연산자 사용)
	-> boolean 값

 1-4. 그렇지 않다면?
	if문은 조건이 참일 경우에 실행되는 구문이라면, if문의 조건과 반대되는 경우에 실행되는 구문이 else문.
	else문은 독립적으로 실행될 수 없고, 반드시 if문의 뒤에 위치해야한다.

 1-5. 여러가지 경우의 수를 분기
	if문과 else문 사이에 else if문으로 두번째 조건, 세번째 조건.. 을 나열할 수 있다
	else if문은 필요한 만큼 나열할 수 있으며, 필요치 않을 경우 else문은 생략 가능하다
 
 	if(1차 조건) {
		..실행할 구문..
	} else if(2차 조건) {
		..실행할 구문..
	} else if(3차 조건) {
		..실행할 구문..
	} else {
		..반대경우 실행할 구문..
	}

 1-6. switch문
	변수값에 대한 경우의 수를 처리하는 switch문
	switch문은 하나의 변수(기준값)에 대한 여러가지 case를 정의하는 구문이다
	if문은 조건에 식(비교식, 부등식)이 사용될 수 있지만, switch문은 분기 조건이 반드시 일치하는 "값"에
	대해서만 처리가능하다.

	switch(기준값) {
		case 값1:
			...실행될 구문...
		case 값n:
			...실행될 구문...
		default:
			..모든 경우에 충족되지 않을 경우 실행될 기본 구문...
			break;
	}

2. 반복문
	for문, while문, do~while문
	사람이 직접 처리하기에 부담스러운 반복적인 작업을 처리하기 위해 사용

 2-1. for문

	for(초기식; 조건식; 증감식) {
		..반복적으로 동작할 구문..
	}

	1~100까지 누적된 합을 구하여라
	-> 1 + 2 + ... + 100

	(1) : 최초로 초기식을 설정한다.
	(2) : 초기식을 설정한 후, 조건식을 판단
	(3) : 만약 조건식이 참이라면 반복적으로 동작할 구문을 1회 수행한다.
	(4) : 반복문을 수행한 후, 증감식으로 이동한다.
	(5) : 증감식을 수행한 후, 다시 조건식으로 이동한다. 여전히 조건식이 참이라면 반복수행을 처리하고,
	그렇지 않다면 for문을 종료한다.

 ---------------------------------------------------------------------------------------------------------------

1. while문
	for문과 마찬가지로 반복적인 처리를 수행하는 문법이다.
	for문은 초기식, 조건식, 증감식을 모두 내장하는 반면, while문은 조건식만을 내장하기 때문에
	초기식과 증감식을 외부에 따로 정의해 주어야한다.

	초기식;
	while(조건식) {
		..반복적 로직..
		증감식;
	}

2. do~while문 
	조건의 판별을 나중에 수행하는 반복문 형태
	초기식을 설정한 후, do{..}안의 문장을 우선적으로 1회 실행하고 조건을 판별하므로,
	조건식이 참이 아니더라도 최소 1회는 실행된다.
		
	초기식;
	do {
		..반복로직..
		증감식;
	} while(조건식);

3. 무한루프
	증감식이 설정되지 않거나, 증감식이 수행되더라도 조건식이 거짓이 되지 않는 형태
	조건식이 항상 참이므로, 반복문이 종료되지 않는다.
	프로그램이 PC의 자원을 매우 많이 사용하게 되므로, 시스템 다운을 발생시킬 수 있다.
	
	for문의 무한루프 예
		for(int i = 0; i < 10; i--) {
 			syso(i);
		}

	while문의 무한루프 예
		while(true) {
			syso ("hello");
		}

4. 문법의 중첩사용
	if, switch, for, while, do~while
	서로 중첩해서 사용하는 것이 가능하다

5. 변수의 범위(=변수의 스코프)
	자신보다 하위블록으로 침투할수있다

	>유효한 범위
	int sum = 100;
	if(sum == 100) {
		syso(sum);
	}
	syso(sum);

	-------------------------------------
	>유효한 범위
	int num = 100;
	for(int i = 0; i < 10; i++) {
		syso(num + i);
	}
	syso(num);

	-------------------------------------
	자신이 선언된 블록 밖으로는 빠져나갈 수 없다.
	>허용되지 않는 범위의 예
	int num = 100;
	int(num == 100) {
		int result = num + 100;
	}
	syso(result);	//에러발생

	-------------------------------------
	>허용되지 않는 범위의 예
	for(int i = 0; i < 10; i++) {
		syso(i);
	}
	syso(i);	//에러발생
	-------------------------------------
	블록안에서 선언된 변수는 블록 밖에서 존재하는 동일한 이름의 변수와는 이름만 동일할 뿐,
	다른 값으로 인식된다.
	int target = 100;

	if(target == 100) {
		int num = target + 100;
	} else {
		int num = target - 100;
	}


 ---------------------------------------------------------------------------------------------------------------

1. 2차원 배열
 1-1. 2차원 배열의 선언
	데이터 타입의 이름 뒤에 대괄호 "[]"를 행과 열에 대하여 각각 지정한다.
	
	데이터형[][] 배열이름;

 1-2. 2차원 배열의 크기 할당
	행과 열에 대한 크기를 명시한다

	배열이름 = new 데이터형[행][열];

 1-3. 2차원 배열의 선언과 할당의 일괄처리

	데이터형[][] 배열이름 = new 데이터형[행][열];

 1-4. 2차원 배열에 대한 값의 대입 방법
	행, 열에 대한 인덱스를 통하여 값을 대입한다.
	
	배열이름[행][열] = 값;	
	
	-2차 배열로 표현
		int[][] grade = new int[3][3];
		grade[0][0] = 75;
		grade[0][1] = 82;
		...
		grade[2][2] = 90;
	
	-일괄 지정하는 경우
		int[][] grade = new int[][] {
			{75, 82, 91},
			{88, 64, 50},
			{100, 100, 90}
		}

 1-5. 2차원 배열의 길이
	2차원 배열의 길이는 행에 대한 측면과 열에 대한 측면을 나누어서 생각한다
	-행의 길이
		-> 1차 배열의 길이는 2차배열에서는 행의 크기로 조회된다
		int rows= grade.length;


	-열의 길이
		-> 열의 길이는 각 행에 대하여 개별적으로 조회해야 한다
		int cols = grade[행].length;

2. 메서드

	public static void main(String[] args) {
		
	}

 2-1. 메서드 => 함수
	f(x) = x + 1
	f(5) = 6
	f(10) = 11
	함수이름	: f
	변수	: x
	식	: x + 1

 2-2. 메서드란
	특정기능(=연산)을 그룹화해서 재사용하기 위한 단위

	public static void 메서드이름() {
		..수행할 연산식..
	}

 2-3. 메서드의 호출
	정의된 메서드는 다른 메서드를 구성하는 {...}안에서 다음의 형식으로 사용될 수 있으며, 이를 메서드를
	호출한다고 한다.

	메서드이름();

 2-4. 메서드의 파라미터
	java프로그램 메서드(=함수)는 자신이 실행되는데 필요한 조건값을 메서드 이름뒤의 괄호안에서
	변수형태로 선언한다. 이를 메서트 파라미터라고 한다.

	public static void 메서드이름(변수형 변수이름) {
		
	}
 
 2-5. 파라미터를 갖는 함수의 사용
	파라미터가 정의된 함수를 사용할 경우, 파라미터에 해당하는 값을 전달해 준다.

	public static void 메서드이름(변수형 변수이름);

	메서드이름(값1);

 2-6. 여러개의 매개변수
	특정 메서드가 연산을 수행하기 위해서 두 개 이상의 조건값이 필요하다면 콤마(,)로 구분해서 명시할 수 있다.

	public static void 메서드이름(변수형 변수이름, 변수형 변수이름, ..) {

	}

 ---------------------------------------------------------------------------------------------------------------

1. 메서드
 1-1. 메서드 리턴값
	-메서드가 연산 결과를 자신이 호출된 위치에 반환하는 것을 "리턴"이라고 하며, 
	반환되는 값을 "리턴값"이라고 한다.
	-메서드 안에서 값을 리턴하기 위해서는 return이라는 키워드를 사용
	-값을 리턴하는 메서드는 선언시에 "void" 키워드 대신, 리턴하는 값에 대한 변수형이 명시된다.
	-void는 리턴값이 없다는 의미이다.

	public static 리턴형 메서드이름(변수형 파라미터1, ..) {
		return 리턴값;
	}

2. 클래스
 2-1. 클래스와 객체의 관게
	-객체를 생성하기 위해서는 객체의 설계도(class)가 필요하다.
 
 2-2. 클래스(Class)
	-객체의 설계도 역할을 하는 프로그램 소스
	-공장에서 하나의 설계도를 사용해서 여러개의 제품을 생산할 수 있는 것처럼
	하나의 클래스를 통해 동일한 구조를 갖는 객체를 여러개 생성할 수 있다.
	-엔진, 문, 바퀴,.. 명사적인 특성 : 멤버 변수, 프로퍼티(=변수)
	-전진, 후진,.. 동사적인 특성 : 메서드
	-동일한 설계로 만들어진 자동차라 하더라도 각각의 자동차를 구성하는 부품들은 그 형태만 같을 뿐,
	실제로는 각각 존재하게 된다.
	-클래스를 작성하면서 그 안에 생성되는 멤버변수들은 여러개의 객체간에 서로 동일한 이름으로
	존재하지만, 실제로는 서로 다른 값이라는 의미
 
 2-3. 클래스의 기본 작성 방법
	
	class 클래스이름 {
		멤버변수;

		void 메서드이름() {..}
	}

	-'class'라는 예약어와 클래스의 이름을 명시하고 {..}블록을 구성한다.
	-멤버변수는 여러 개 존재할 수 있다. 이때, 값을 선언과 동시에 할당할 수 있고,
	객체를 통해 간접적으로 할당할 수도 있다.
	-메서드는 여러개 존재할 수 있다.
	-클래스 안에 포함된 멤버변수와 메서드를 특성에 따라 그룹화 하기 위한 기법이 클래스를 작성하는 것이라고
	이해할 수 있다.

 2-4. 객체의 생성 방법
	-객체의 선언
		클래스이름 객체이름;

	-객체의 할당
		객체이름 = new 클래스이름();

	-선언과 할당의 통합
		클래스이름 객체이름 = new 클래스이름();

 2-5. 객체의 사용
	-객체 안에 포함된 변수나 메서드는 점(.)으로 연결하여 접근한다.
	
		객체이름.멤버변수;
		객체이름.메서드이름();
		객체이름.메서드이름(값, 값, ..);

 2-6. 값이 대입되지 않은 멤버변수를 갖는 클래스
	-클래스란 객체를 위한 틀을 제공하는 것이기 때문에, 클래스 작성과정에서 멤버변수에 대입된 값은,
	객체를 통하여 멤버변수의 값을 지정하기 전까지 사용될 "기본값"으로서의 의미이다.
	-객체를 통하여 새로운 값이 대입되면 클래스 작성시에 멤버변수에 대입한 값은 의미를 잃어버리게 된다.
	때문에, 일반적으로 클래스 작성시에는 멤버변수에 값을 지정하지 않는다.


 ---------------------------------------------------------------------------------------------------------------

1. 반복문에서의 break와 continue
	break: 반복문 안에서 break 키워드를 만나면 반복을 강제로 종료한다
	continue: 실행흐름이 증감식으로 강제 이동한다.

	for( 초기식; 조건식; 증감식 ) {
		..반복적으로 동작할 구문1..

		if(조건식) {continue;}
		if(조건식) {break;}

		..반복적으로 동작할 구문2..
	}

2. 배열
	변수를 그룹으로 묶은 형태의 한 종류로서, 사물함 같은 형태를 갖고있다.
	하나의 배열 안에는 같은 종류(데이터형)의 값들만 저장될 수 있다.

 2-1. 배열의 선언
	-데이터형[] 배열이름;

 2-2. 배열의 생성
	-배열이름 = new 데이터형[크기];

 2-3. 배열 생성의 예 : 3개의 int형 변수를 저장할 수 있는 배열 생성
	int[] grade;		// 여러개의 int형 변수를 저장할 수 있는 배열의 선언
	grade = new int[3];	//배열의 칸은 3칸으로 할당

 2-4. 배열의 선언과 크기 지정에 대한 일괄처리
	-데이터형[] 배열이름 = new 데이터형[크기=;
	int[] grade = new int[3];

 2-5. 배열의 모양
	생성된 배열은 사물함과 같이 각각의 칸에 값들이 저장되고, 각각의 칸은 0부터 일련번호가 지정된다.
	(일련번호 = 배열의 인덱스)

 2-6. 배열에 값을 저장하기
	배열은 값을 저장할 수 있는 공간일 뿐, 그 자체가 값은 아니다.
	값이 대입되지 않은 경우, 숫자형 0, boolean형 false가 자동으로 대입된다.
	배열안에 값을 저장하기 위해서는 인덱스번호를 사용하여 각각의 칸에 직접 값을 대입해야한다.
	-배열이름[인덱스] = 값;
	-둘리의 점수를 배열로 표현
		int[] grade = new int[3];
		grade[0] = 75;
		grade[1] = 82;
		grade[2] = 91;

 2-7. 배열의 크기 설정과 값 할당에 대한 일괄처리

	데이터형[] 배열이름 = new 데이터형[] {값1, 값2, ..., 값n};
			또는
	데이터형[] 배열이름 = {값1, 값2, ..., 값n};

 2-8. 배열값 사용하기
	배열안에 저장되어 있는 값들을 사용하여 연산이나 출력등의 처리를 위해서는 배열에 부여된
	인덱스 값을 통해서 데이터에 접근해야한다.
	System.out.println(grade[1]);	//82
	System.out.println(grade[2]);	//91

 2-9. 배열과 반복문
	-배열의 특성 : 0 ~ (배열크기 - 1) 만큼의 인덱스 값을 순차적으로 갖는다.
	-일정 범위를 갖고 순차적으로 증가하는 인덱스 값의 특성을 활용하면 반복문 안에서
	배열의 값을 할당하거나, 할당된 값을 읽어들이는 처리가 가능하다.
 
 2-10. 배열의 크기(길이)
	-배열의 길이를 얻기 위해서는 "배열이름.length"형식으로 접근한다
	-grade라는 배열을 생성한 경우 배열의 길이
		int size = grade.length;
	-배열의 길이값은 주로 반복문의 조건식에서 반복의 범위를 지정하기 위하여 사용된다.	

 2-11. 다차원 배열
   -1차원 배열
	->한 줄만 존재하는 사물함 한줄과 같이 구성된 배열
	->행에 대한 개념이 없고, 열에 대한 개념만 존재하기 때문에 "배열이름.length"로 
	몇 칸인지를 알아보는 기능	
   -2차원 배열
	->1차 배열의 각 칸에 새로운 배열을 넣는 형태
	->1차 배열의 각 칸은 행이 되고, 각각의 칸에 추가된 개별적인 배열이 "열"의 개념이 되어,
	"행렬"을 구성하게 된다.

 ---------------------------------------------------------------------------------------------------------------

1. 메서드를 포함하는 클래스
	-메서드란 프로그램에서 하나의 동작 단위를 의미한다.
	-두 개 이상의 메서드가 서로 동일한 대상을 위해 존재할 경우, 이 메서드들을 클래스에 포함시켜
	그룹화할 수 있다.
	-클래스에 멤버변수와 메서드가 공존할 경우, 멤버변수는 모든 메서드가 공유하는 전역변수로 존재하게 된다.

 1-1. 변수의 종류
	-멤버변수(=전역변수)
		->클래스 안에서 선언된 변수로서, 클래스 블록 범위 안에서 유효하다.
	-지역변수
		->메서드 안에서 선언된 변수로서, 메서드의 블록을 빠져나가지 못한다.
		그러므로 다른 메서드는 해당변수를 인식하지 못한다. 이 규칙은
		조건, 반복문과 같은 블록 {}를 형성하는 모든 경우에 해당된다.

 1-2. 메서드만을 포함하는 클래스
	-객체 안에 멤버변수(=전역변수)가 포함되지 않는다
		-> 데이터가 포함되지 않는다.
	-객체 안에 포함된 메서드를 호출하여 결과를 만들기 위한 목적이므로 
	굳이 여러개의 객체를 생성할 필요가 없다.


2. this
 2-1. this란
	클래스 안에서 this를 사용하여 "자기자신"을 표현한다.

 2-2. this를 사용하여 지역변수와 멤버변수 구분하기
   -멤버변수와 지역변수가 동일한 이름으로 공존할 경우, 유효성의 범위가 작은 변수가 우선적으로 인식된다.	

	class User {
		String name;	// 전역변수(1)

		public void setName() {
			String name;		// 지역변수(2)
			name = "자바학생";		// 지역변수 name
			this.name = "JSP학생";	// 전역변수 name
			// this.name : 멤버변수로 선언된 name을 의미함
		}
	}
	------------------------------------------------------------------------
	-파라미터도 해당 메서드 안에서만 유효한 지역변수의 일종이다.
	-파라미터를 사용하여 멤버변수의 값을 간접적으로 설정하고자 할 경우,
	변수의 이름을 서로다르게 사용하는것 보다는 이름은 동일하게 지정하고
	this 키워드를 사용하여 멤버변수와 파라미터를 구별하는 것이 java언어의 일반적인 처리방식이다.

	class Student {
		String name;

		public void setName(String name) {
			this.name = name;
		}
	}

 2-3. 현재 클래스의 메서드를 의미하는 용도로서의 this
	-메서드의 경우 this.getName()이 아닌, getName()만 사용하더라도 
	코드의 가독성의 문제는 없다.

	class Student {
		public String getName() {
			String name = "자바학생";
			return name;
		}

		public void sayName() {
			String myName = this.getName();
			System.out.println(myname);
		}
	}	

3. 클래스, 메서드, 상수의 이름 규칙
 3-1. 공통규칙
	-영어 + 숫자 + 언더바(_)의 조합이고, 첫 글자 반드시 영어

 3-2. 클래스 이름 규칙
	-첫 글자는 대문자로 시작, 나머지 글자는 소문자로 표시한다.
	-두 개 이상의 단어를 조합해야 할 경우 새로운 단어는 대문자로 시작한다.
	
	class Student
	class MyClass
	class NetworkHelper

 3-3. 메서드, 변수 이름규칙
	-대부분 소문자로 구성되지만, 두 개 이상의 단어를 조합할 경우 새로운 단어는 
	언더바(_) 또는 대문자로 표시

	int age;
	String userName;
	String memberCount;
	int student_age;

 3-4. 상수 이름규칙
	-모두 대문자로 표시한다
	
	final double PI;
	final int COLOR;



4. 생성자(Constructor)

	class Member{ 
		Member() {
			
		}
	}

	Member member = new Member();

   -new 키워드를 사용하여 객체가 생성될 때 자동으로 실행되는 특수한 형태의 메서드
   -리턴형을 명시하지 않으며, 메서드의 이름은 클래스와 동일하다.
   -자동으로 실행되는 특성 때문에, 객체가 생성되면서 해당 객체의 특성을 초기화하기 위하여 사용된다.
	(ex:멤버변수의 초기값을 할당하는 용도)


 ---------------------------------------------------------------------------------------------------------------

1. 생성자
 1-1. 기본 생성자
	-파라미터가 없는 생성자
	-클래스에 특별히 생성자가 정의되지 않은 경우, java컴파일러는 기본생성자가 존재한다고 인식한다.

	class User {
		
		User() {
			// 생성자는 있지만, 내용은 비어 있다.
		}
		
	}

 1-2. 파라미터를 갖는 생성자
	-생성자도 메서드의 한 종류이므로 파라미터를 함께 정의하는 것이 가능하다.
	-생성자의 파라미터를 멤버변수에 복사하는 것으로 객체의 초기화를 외부적인 요인에 의해 처리할 수 있다.

2. 은닉성
 2-1. 은닉성이란?
	-멤버변수나 메서드가 객체에 노출되지 않도록 설정하는 기법
	-객체를 사용하는 측의 실수로 인한 기능의 오작동을 방지하기 위해, 
	클래스의 일부를 숨기는 처리를 말한다.

 2-2. 적용방법
	-변수의 이름이나 메서드 이름 앞에 "접근 한정자"를 지정한다.

	-public
		-> 모든 곳에서 접근 가능하다.
		-> 일반적으로 모든 메서드 앞에 명시한다.
	-private
		-> 클래스 안에서만 사용 가능, 객체를 통해 접근할 수 없다.
		-> 일반적으로 모든 멤버변수 앞에 명시한다. 
	-protected
		-> 현재 클래스 내의 다른 자원이나, 같은 패키지 안에 존재하는 클래스와
		하위 클래스에서 접근 가능하다. 잘 사용하지 않는다.
	-default
		-> 접근 한정자를 명시하지 않은 경우. 현재 클래스 내의 다른 자원이나
		동일 패키지 내의 다른 클래스에서 접근 가능하다. 잘 사용하지 않는다.
	
 2-3. 자바빈즈(JavaBeans)
	-getter, setter
	-멤버변수가 은닉된 형태로 선언된 경우, 프로그램의 가장 근본적인 목적인 데이터에 접근하는
	방법이 사라지므로 메서드를 통하여 간접적으로 접근하는 방법이 마련되어야 한다.
	-getter, setter 는 은닉된 멤버변수에 간접적으로 접근하기 위하여 정의된 메서드들을 
	의미하는 용어이다.

		-> getter : 은닉된 멤버변수의 값을 리턴하기 위한 메서드 	
		-> setter : 파라미터로 전달된 값을 멤버변수에 복사하기 위한 메서드

	-메서드 작성 예
	
		멤버변수 이름 : private String userName;
		getter     : String getUserName() {	}
		setter     : void setUserName(String userName) {	}
		
	-"get", "set" 접두사 뒤에 변수이름을 첫 글자가 대문자인 형태로 명시
	-getter는 연결된 멤버변수의 데이터 타입을 리턴형으로 명시
	-setter는 연결된 멤버변수의 데이터 타입을 파라미터 형식으로 명시

 2-4. 클래스에 접근 한정자를 지정하는 경우
	- public : 객체 생성이 가능하다. 서로 다른 소스코드에 정의된 클래스끼리도 객체생성이 가능하다. 

	-private : 클래스에 적용할 수 없다.

	-protected : 클래스에 적용할 수 없다.

	-default : 동일한 소스코드에 정의된 클래스끼리만 객체로 생성 가능하다.
		  (지금까지의 예제 형태)	


3. 상속성
 3-1. 클래스 간의 상속이란?
	-클래스간에는 부모-자식의 상속관계를 설정할 수 있다.
	-부모 클래스A를 자식 클래스B가 상속 받을 때, B는 A의 모든 멤버변수와 메서드를 자신의 것으로
	상속받게 된다. (단, private로 설정된 기능은 상속되지 않는다.)
	-상속 가능: public, protected
	-자식 클래스B는 A의 정의된 public과 protected 기능을 직접적으로 코딩하지 않더라도
	자신의 것으로 사용할 수 있게 된다.
 
 3-2. 상속의 정의 방법
     -extends 키워드를 사용해서 부모 클래스의 이름을 명시한다.
	
	public class 자식클래스 extends 부모클래스 {.....}

 ---------------------------------------------------------------------------------------------------------------

1. 상속
 1-1. 클래스 다이어그램
	-클래스의 구조를 표현하는 클래스 다이어그램에서, 상속은 자식클래스가 부모클래스를 가리키는 
	화살표로 표현한다.
	-상속관계가 이루어질때, 부모클래스를 super클래스 라고한다.
 
 1-2. 상속의 활용
	- 기존에 존재하는 클래스의 소스 수정없이 기능을 확장하고자 하는 경우
	- CalcChild클래스는 CalcParent클래스를 상속받기 때문에, 별도의 소스코딩 없이도
	plus()메서드와 minus()메서드를 포함하게 된다.
	- CalcChild클래스에 times()메서드와 divide()메서드를 추가하면, 상속받은 메서드에
	새로운 기능을 추가하는 효과를 얻을 수 있다.

 1-3. 상속의 활용(2)
	- 여러개의 클래스에서 공통되는 기능을 추출하여 공유하기
	- 질문/답변 게시물의 한 단위를 표현하기 위한 QNAArticle클래스와
	자료실의 게시물을 표현하기위한 FileArticle클래스는 글번호와 제목이라는
	공통된 특성을 갖는다.
	- 공통 기능을 별도의 클래스로 추출해내면, 코드의 재사용 및 수정이 용이하다.

2. 다형성 - 오버라이드
	- 육군(Army), 해군(Navy), 공군(AirForce)은 Unit이라는 클래스를 통하여
	공통속성을 정의하고 있다.
	- 공통속성 -> 이름, 공격메서드
	- 같은 이름이지만 다른 동작을 수행해야 하는 필요성
	- 모든 군대는 '공격' 이라는 공통된 특성을 갖지만 공격하는 방법은 육/해/공군이 서로
	다르게 처리되야만 한다.
	
 2-1. 다형성을 구현하기 위한 Override
	- 부모 클래스가 갖고있는 기능을 자식 클래스가 재정의
	- 부모 클래스에 정의된 것과 동일한 이름을 갖는 메서드를 자식클래스가 재정의한 경우,
	부모클래스의 기능은 자식에게 가려진다.
	- 이렇게 부모의 기능을 재정의 하는 것을 메서드 Override라 한다.

3. Super 키워드
	- 클래스의 상속관계에서 자식 클래스가 부모클래스를 가리키는 예약어

 3-1. 사용방법
	- 멤버변수 이름 앞에 명시
		-> 부모클래스의 멤버변수를 의미한다. 하지만 부모클래스의 멤버변수는
		이미 모두 상속되어 있기 때문에 이 경우에는 this키워드를 사용하는 것과 
		동일한 결과이기에 잘 사용하지 않는다.
	- 메서드 이름 앞에 명시
		-> 부모클래스의 메서드를 의미한다.
		-> 재정의 되지 않은 메서드 => 이미 상속되어 있기 때문에 this 키워드를 
		사용하는 것과 동일한 결과를 갖는다.
		-> 재정의 된 메서드 => Override 된 메서드 이름 앞에 사용하게 되면
		재정의 되기 이전의 원본 메서드를 의미한다.
	- 키워드 자체를 메서드처럼 사용
		-> super();
		-> 부모 클래스의 생성자를 의미한다.

4. 상속 관계에서의 생성자 처리
 - 생성자가 정의된 클래스의 상속 제한
 - 생성자는 상속되지 않는다.
 - 생성자가 정의된 클래스는 객체 생성을 위해서 반드시 생성자 파라미터를 전달받아야 하기 때문에,
 파라미터를 갖는 생성자가 정의된 클래스를 상속 받게 되면 에러가 발생된다.
 - 부모 생성자의 강제 호출
	-> 생성자가 정의된 클래스를 상속받은 경우에는 자식 클래스의 생성자를 통해서
	부모 생성자를 강제로 호출해야 한다.
	-> 부모 생성자를 호출하는 방법은 super키워드를 메서드 이름으로 사용하는 것이다.


 ---------------------------------------------------------------------------------------------------------------

1. @Override
	-메서드 재정의 과정에서의 오타 방지 옵션
	-"@Override" 는 이 키워드가 명시된 위치 아래에 정의되는 메서드가 부모 클래스에
	존재하지 않을 경우 구문에러로 처리한다.
	-부모 클래스의 메서드를 재정의하고자 할 경우, 의도치 않은 실수를 예방하기 위한 
	'오타 방지용 옵션'이다.
	-여러개의 메서드를 재정의 한다면 재정의 되는 모든 메서드들 위에 각기 명시해야한다.

2. 다형성 - 오버로드
 2-1. 메서드 오버로드(Overload)
	-원칙적으로 하나의 클래스 안에서는 동일한 이름의 메서드가 두 개 이상 존재할 수 없지만,
	이를 가능하게 하는 예외적인 처리 기법
	
 2-2. 이름이 동일한 메서드를 정의하기 위한 조건
	-메서드간의 파라미터가 서로 달라야한다.
		-> 파라미터의 데이터 타입이 다르다.
		(데이터형이 동일하고 변수의 이름이 다른 경우는 동일한 파라미터로 인식된다)
		-> 파라미터의 개수가 다르다
		-> 서로 다른 데이터형을 갖는 파라미터들의 전달 수서가 다르다.
	-리턴형이 다른 경우는 오버로드의 성립에 아무런 영향을 주지 않는다.

 2-3. 오버로드의 예시
	-파라미터의 데이터 형이 서로 다르기 때문에 오버로드 성립
	
	public void user(int a) {}
	public void user(long a) {}

	-파라미터의 개수가 서로 다르기 때문에 오버로드 성립
	
	public void user(int a) {}
	public void user(int a, int b) {}

	-데이터형의 전달 순서가 서로 다르기 때문에 오버로드 성립
	
	public void user(int a, String b) {}
	public void user(String a, int b) {}

	-오버로드 성립 불가
		데이터형이 동일하고 변수의 이름이 다른 경우는 동일한 파라미터로 인식된다

	public void user(String a , int b) {}
	public void user(String b, int a) {}
	

 ---------------------------------------------------------------------------------------------------------------

1. 생성자의 Overload
 1-1. 객체 생성 방법의 다양
	- 생성자 역시 메서드의 한 종류이므로 Overload가 가능하다.
	- 생성자를 Overload할 경우, 해당클래스에 대해 '객체를 생성하는 방법'을 
	다양하게 준비할 수 있게 된다.
	- 정의된 생성자의 수 만큼 객체생성방법이 늘어나게 된다.
	
 1-2. this 키워드를 사용한 생성자 Overload
	- this키워드를 메서드처럼 사용할 경우, 현재 클래스의 다른 생성자를 의미한다.
	- this키워드를 사용하여 생성자 Overload를 간결하게 처리하기
	- 파라미터가 서로 다른 생성자들이 하나의 완전한 생성자를 호출하도록 하여,
	데이터의 초기화를 한 곳에서 일괄적으로 처리하도록 구현할 수 있다.

 ---------------------------------------------------------------------------------------------------------------

제어문
	조건문
		if문

		switch문
		
		switch(변수명){
		case 1: case 3: case 5:	//or
			홀수
			break;
			
		case 2: case 4: case 6:
			짝수
			break;
		}

	반복문
		for	 : 몇 번 반복할지 알때
		while	 : 몇 번 반복할지 모를때
		do~wihle 

배열
배열의선언
	int[] arData = {1, 2, 3,...}	// 값을 정확히 알고 있을 때
	
	int[] arData = new int[칸수]	// 값은 모르지만 칸 수는 알고있을 때
	
	int[] arData = null;		// 값도 모르고 칸 수도 모를 때
	
	arData = new int[칸수];

RAM
====================
OS kernel space		드라이버
--------------------
Stack			지역변수, 매개변수
--------------------
Heap			동적 메모리
--------------------
Data영역			전역변수, 정적변수(static)
--------------------
BSS			초기화되지 않은 전역변수
--------------------
Text			상수, 코드
====================



메소드
	이름()

	단, 키워드()는 메소드가 아니다.
	if(), switch(), while(), for()

	리턴타입 메소드명(매개변수) {
		실행할 문장;
		return 리턴값;
	}
	
	int add(int num1, int num2) {
		return num1 + num2;
	}


	1. 재사용(특정성을 부여해서는 안된다!)
	2. 소스코드 간결화

클래스(반)
	1. 타입이다.
	2. 주어이다.
		Monkey.eat("바나나");

생성자
	1. 해당 클래스의 필드를 메모리에 할당하고 할당된 필드의 주소값을 가지고온다.
	2. 초기화

객체화(인스턴스)
	추상적인 개념을 구체화 시키는 작업을 객체화(인스턴스)라고 하며,
	클래스(추상)를 구체화 시킨 것을 객체(인스턴스 변수)라고 한다.

	클래스명 객체명 = new 생성자();

this

class Car {
	String brand;

	void engineStart() {
		System.out.println(this.brand + "시동 킴");
	}
}

상속(inheritance)
	1. 기존에 선언된 클래스의 필드를 새롭게 만들 클래스의 필드로 사용하고자 할 때 
	2. 여러 클래스 선언 시 필드가 겹치는 경우, 부모 클래스를 먼저 선언하고
	공통필드를 묶어서 자식 클래스에게 상속해준다.

부모 클래스, 상위 클래스, 슈퍼 클래스, 기반 클래스
자식 클래스, 하위 클래스, 서브 클래스, 파생 클래스

super
super()

재정의(Overriding)
------------------------------------------------------------
접근 권한 제어자
	default	: 다른 패키지에서 접근 불가
	public	: 다 가능, 내가 여기 짱이야
	protected : 다른 패키지에서 접근 불가(자식이면 가능)	
	private	: 같은 클래스만 접근 가능, 메소드로만 접근하자!
------------------------------------------------------------
Casting
추상클래스
인터페이스
예외처리
API
자료구조(컬렉션 프레임워크)
쓰레드
파일입출력


 ---------------------------------------------------------------------------------------------------------------

모든 자식은 부모타입이다.

Casting
	up casting : 자식값을 부모타입으로 형변환
	down casting : up casting된 객체를 자식타입으로 형변환
	※ 부모 값을 자식 타입으로 형변환 시 오류

Casting을 사용하는 이유
	모든 자식 값을 전달받기 위해서는 동일한 타입의 저장공간으로 받아야 한다.
	하지만 자식끼리는 서로 타입이 다르기 때문에 한번에 전달받을 수가 없다.
	이 때 up casting을 사용하면, 모든 자식이 부모 타입이므로 하나의 저장공간에
	모든 자식을 받을 수 있게 된다.
	만약 up casting으로 자식값을 전달받았다면, 자식에서 새롭게 구현한 기능들은 
	사용할 수 없기 때문에 down casting을 통해서 복구하여 사용한다.

객체 간 타입 비교
instanceof
	a instanceof A : 조건식, 참 또는 거짓 중 하나가 나오는 식
	- a가 A타입이면 true
	- a가 A타입이 아니면 false
----------------------------------------------------------------------
추상 클래스
	필드 안에 구현이 안된 메소드가 선언되어 있는 클래스를 추상 클래스라고 한다.
	이 때 구현되지 않은 메소드를 추상 메소드라고 부른다.
	반드시 재정의를 통해 구현해야 메모리에 할당되기 때문에 "강제성"을 부여하기
	위해서 추상 메소드로 선언한다.

추상 클래스 선언
	abstract class 클래스명 {
		abstract 리턴타입 메소드명(자료형 매개변수,...);
		*일반 메소드도 선언 가능
	}

 ---------------------------------------------------------------------------------------------------------------

인터페이스(interface) : 틀
	추상클래스를 고도화 시킨 문법.
	상수와 추상메소드만 존재한다.
	구현은 인터페이스를 지정한 클래스에서 진행하고,
	인터페이스를 다른 클래스에 지정할 때에는 implements 키워드를 사용한다.
--------------------------------------------------------------------
추상클래스와 인터페이스의 관계
	인터페이스를 클래스에 바로 지정하면 모든 메소드에 강제성이 부여되어서 전부 다 
	구현해야 한다. 하지만 일반적인  상황에서는 모든 것이 아닌, 필요한 메소드를 
	골라서 재정의 해야한다.
	인터페이스를 직접 지정하지 않고 다른 클래스에 지정한 후 바디(중괄호)를 만들어 놓는다면, 
	강제성이 소멸되고 이 클래스를 상속받아서 필드를 구현한다면, 골라서 재정의할 수
	있게 된다. 이 때 중간에서 강제성을 없애주는 클래스를 추상 클래스로 선언하며, 클래스
	이름 뒤에 Adapter를 붙여서 목적을 알려준다.
---------------------------------------------------------------------
다중 상속
	여러 부모 클래스를 상속하는 것을 다중 상속이라고 한다.	
	JAVA는 모호성 때문에 다중 상속을 지원하지 않는다.
	하지만 JDK8버전부터는 인터페이스에 default 메소드 선언을 허용하며,
	여러 개를 지정할 수 있는 인터페이스 특성 상 다중상속을 지원하는 것이나 다름이 없다.
	
모호성(ambiguity)
	하나의 자식이 여러 부모를 상속받을 때 부모 필드에 동일한 이름의 필드가 있다면,
	어떤 부모의 필드인지 알 수가 없다. 이를 모호성이라고 부른다.

모호성 해결 방법
 - 상황1 : 두 개의 인터페이스 내에 같은 이름과 매개변수의 메소드가 선언되어 있다.
 - 해결1 : 자식 클래스에서 재정의하여 사용한다.

 - 상황2 : 부모 클래스의 메소드와 인터페이스의 디폴트 메소드의 이름과 매개변수가 같다.
 - 해결2 : 부모 클래스의 메소드가 사용된다.
-----------------------------------------------------------------------
* 인터페이스도 타입이다.
* 인터페이스는 부모이며, 구현한 클래스가 자식이 된다.

마커 인터페이스(Marker Interface)
	클래스들을 그룹화하기 위한 목적으로 사용한다.
	인터페이스는 지정한 클래스의 부모이며, 모든 자식은 부모의 타입이므로
	마커 인터페이스를 지정받은 클래스들이 하나의 타입으로 묶이게 된다.


 ---------------------------------------------------------------------------------------------------------------

내부 클래스(Inner class)
	하나의 클래스에서 a작업과 b작업이 있을 때에는 따로 분리하여 클래스로 만들지 않고,
	클래스안에 클래스를 선언하여 설계한다. 이 때 밖에있는 클래스를 외부 클래스라고 하며,
	안에 선언된 클래스를 내부 클래스라고 한다. 외부 클래스가 메모리에 할당되어야
	내부 클래스를 객체화할 수 있기 때문에 클래스를 숨기기 위해서 내부 클래스를 사용하기도 한다.
	이를 캡슐화 또는 은닉화라고 부른다.	
	내부 클래스는 외부 클래스의 필드이기 때문에 외부 클래스의 필드를 자신의 필드처럼 가져다 
	사용할 수 있게 된다.

익명 클래스(Anonymous inner class)
	이름이 없는 클래스이며 구현되지 않은 필드를 구현하기 위해서 일회성으로 생성되는 
	클래스이다.
----------------------------------------------------------------------
함수형 인터페이스(Functional interface)
	인터페이스 중 추상 메소드를 하나만 가지고 있는 인터페이스를 함수형 인터페이스라고 한다.
	이 때 @FunctionalInterface를 인터페이스 위에 작성하여 단 하나의 추상메소드만
	선언할 수 있도록 제한해야 한다.

람다식(Lambda Expression)
	이름이 없는 메소드로서 변수처럼 사용이 가능하며, 매개변수로도 전달이 가능하다.
	함수형 인터페이스는 추상메소드가 한 개만 선언되기 때문에 메소드 이름이 필요없다.
	따라서 람다식을 익명 메소드(Anonymous Method)라고도 부른다.
	
람다식 문법
	1. (매개변수 형식 나열, ...) -> 리턴값;
	2. (매개변수 형식 나열, ...) -> {2개 이상의 실행할 문장;, return 리턴값;};

[실습]
	함수형 인터페이스를 선언하고 이름과 성을 전달받는 추상메소드를 선언한다.
	클래스를 선언하고 함수형 인터페이스를 매개변수로 받는 static 메소드를 선언한다.
	외부에서 구현된 값을 전달받은 후 static메소드에서 이름과 성을 전달하여 전체
	이름을 출력하도록 구현한다.
	main 메소드에서는 static 메소드를 사용하여 전체 이름을 출력한다.


[심화실습]
	여러개의 정수를 입력받아서 알맞는 덧셈, 뺄셈 결과를 확인하는 애플리케이션 제작
	입력 예1) 7 + 35 - 9
	출력 예1) 33

	입력 예2) -9 + 8 + 10
	출력 예2) 9

	*사용자가 정상적으로만 입력한다는 가정하에 구현하도록 한다.
	*두 정수를 전달받은 후 int로 리턴하는 calc추상메소드 선언(함수형 인터페이스
	제작)
	*두 정수의 덧셈, 뺄셈을 구해주는 함수형 인터페이스를 리턴하는 static메소드
	선언(람다식 리턴)
	*전체 식을 전달받은 후 String[]로 리턴하는 getOpers 추상메소드 선언
	(함수형 인터페이스 제작)
	*main메소드에 getOper를 람다식으로 구현
	*첫번째 정수가 음수일 경우 오류해결

 ---------------------------------------------------------------------------------------------------------------

[심화실습]
	여러개의 정수를 입력받아서 알맞는 덧셈, 뺄셈 결과를 확인하는 애플리케이션 제작
	입력 예1) 7 + 35 - 9
	출력 예1) 33

	입력 예2) -9 + 8 + 10
	출력 예2) 9

	*사용자가 정상적으로만 입력한다는 가정하에 구현하도록 한다.
	*두 정수를 전달받은 후 int로 리턴하는 calc추상메소드 선언(함수형 인터페이스
	제작)
	*두 정수의 덧셈, 뺄셈을 구해주는 함수형 인터페이스를 리턴하는 static메소드
	선언(람다식 리턴)
	*전체 식을 전달받은 후 String[]로 리턴하는 getOpers 추상메소드 선언
	(함수형 인터페이스 제작)
	*main메소드에 getOper를 람다식으로 구현
	*첫번째 정수가 음수일 경우 오류해결

==========================================================================
예외 처리(Exception)
	에러 : 심각한 오류
	예외 : 덜 심각한 오류

예외 처리 문법
	try{
		예외가 발생할 수 있는 문장

	}catch(예외이름 객체명) {
		예외 발생 시 실행할 문장
		
		예외발생 시 해당 예외 필드가 메모리에 할당된다.
		할당된 주소를 선언한 객체로 받지 못한다면 프로그램이 강제 종료된다.
		이를 막기 위해 동일한 예외타입의 객체를 선언하여 catch문 안의 문장으로
		대체하도록 구현한다.

	}catch(예외이름 객체명) {
		예외 발생 시 실행할 문장

	}...
	}finally{
		예외 발생 여부에 상관없이 무조건 실행할 문장
		* 외부 장치와 연결했을 경우 다시 닫을 때 주로 사용한다.
	}

======================================================================
API(Application Programming Interface)
	개발에 필요한 라이브러리들의 집합.
	선배 개발자들이 만들어 놓은 소스코드.
	
	- 내부 API
		JDK 설치 시 제공해주는 기본 API
		doc.oracle.com/javase
		
	- 외부 API
		선배 개발자들이 개발한 패키지 및 클래스들을 의미한다.
		보통 JAR파일로 배포하며 자바 프로젝트의 build path에 추가하여 사용할 
		수 있다.

 ---------------------------------------------------------------------------------------------------------------

Object(최상위 부모 클래스)
	1. toString()
		항상 객체명을 출력할 때에 toString()이 생략된다.
		toString()을 통해 출력되는 문자열이 마음에 들지 않는다면,
		재정의하여 수정하도록 한다.
		클래스의 필드가 초기화되었는지, 전달받은 값이 어떤 것인지 검사할 때,
		toString()을 재정의하여 객체명을 출력함으로써 확인이 가능하다.
	
	2. equals() : 주소값 비교(==)
		String 클래스에서 값 비교로 재정의되었다.
		문자열 비교에서는 반드시 equals()를 사용하고,
		null을 비교할 때에는 ==으로 비교한다.

	3. hashCode() : 해당 객체의 주소값(메모리상의 주소가 아닌 hash값을 통한 중복없는 값)
-------------------------------------------------------------------------------
Wrapper Class : 기본 자료형들의 클래스 타입
	클래스타입 객체 = new 클래스타입(일반타입의 값);	// boxing
	클래스타입 객체 = 클래스타입.valueOf(일반타입의 값);	// boxing

	일반타입 변수 = 객체.000Value();	// unboxing
			(doubleValue / intValue...)

	JDK4 버전 이상부터는 auto를 지원한다.

	클래스타입 객체 = 일반타입의 값;	// auto boxing
	일반타입 변수 = 객체;	// auto unboxing

Wrapper Class를 사용하는 이유
	원시타입(일반타입)을 박싱하면 다양한 메소드를 제공받을 수 있다.(클래스타입으로 박싱되므로)
	여러 일반 타입을 하나의 타입으로 묶기 위해서는 반드시 클래스타입(Wrapper Class)로 
	사용해야 되고, 이 때에는 박싱을 해준다.


[숙제]
	1, 3.5, 12.5F, 'A', "ABC", true
	위 6개의 값을 6칸 배열에 담기, String[]은 사용하지 않는다!


 ---------------------------------------------------------------------------------------------------------------

알고리즘
	어떤 문제가 발생되었을 때 해결할 수 있는 절차 혹은 순서
자료구조
	의미 없는 데이터를 하나의 정보로 만들어주는 알고리즘들의 집합
	수집한 자료를 저장하고 관리하는 방법.

컬렉션 프레임워크(Collection Framework) : 자료구조
	많은 데이터를 쉽고 효과적으로 관리할 수 있는 표준화된 방법을 제공하는
	클래스들의 집합

1. List extends Collection
 -List 구현 클래스
	Vector : 용량관리, 보안성 강화, 처리량 감소
	LinkedList : FILO으로 인해 넣을 때는 빨라도 뺄 때에는 상대적으로 느리다.(인덱스가 없기때문)
	ArrayList : 인덱스로 데이터를 관리한다.
		    컬렉션 클래스 중 실무에서 가장 많이 사용되는 클래스이다.
		    배열의 특징인 인덱스를 이용하여 값을 저장하고 관리한다.

 - 배열과 ArrayList의 차이
	배열은 길이에 제한을 두어야 할 때 자주 사용되고
	ArrayList는 몇 개의 데이터가 들어올 지 알 수 없을 때 사용한다.

2. Set extends Collection


// 리스트, 셋, 컬렉션은 인터페이스임
// 리스트&셋 만들기 -> 공통요소 있으니 컬렉션 만들어줌
// First In Last Out

3. Map


 ---------------------------------------------------------------------------------------------------------------
[실습]
	User 클래스를 선언한다.
	- 이름, 아이디, 비밀번호, 휴대폰 번호
	- 모든 필드는 private으로 설정한다.
	- 기본 생성자를 선언한다.
	
	UserField 클래스를 선언한다.
	- ArrayList로 회원을 저장할 수 있는 DB를 선언한다
	- 아이디 중복검사 메소드
	- 회원가입 메소드(암호화)
	- 로그인 메소드(암호화)
================================================================
Set : 집합
	- 구현 클래스
	HashSet
		집합에서는 중복되는 원소를 포함할 수 없는 것 처럼
		HashSet이라는 자료구조는 중복되는 값을 무시한다.
		저장된 값들은 인덱스가 없기 때문에 순서가 없다.
		값의 유무 검사에 특화되어있는 자료구조이고 해쉬코드로
		유무검사가 진행된다. 검사의 속도가 상대적으로 좋다.

	- 순서 부여 : iterator()
		순서가 없는 객체에 순서를 부여하거나, 순서가 있어도 iterator
		방식의 순서로 변경하고자 할 때 사용한다.
		hasNext()를 통해 다음 값이 있는 지 검사하고, next()를
		사용하여 값을 가져온다.


 ---------------------------------------------------------------------------------------------------------------

Map
 - 구현 클래스
	HashMap(서버 간 데이터 교환)
		Key와 Value 한 쌍으로 저장되며, 검색의 목적을 가지고 있다.
		Key는 중복된 값을 넣으면 Value가 최근 값으로 수정되고
		중복되지 않은 값을 넣으면 새롭게 추가된다.
		Value는 중복이 가능하다.
================================================================



 ---------------------------------------------------------------------------------------------------------------

프로그램
	실행이 안 된 상태.

프로세스
	실행된 프로그램.
	운영체제로부터 시스템 자원을 할당받는 작업의 단위.
	JAVA는 운영체제가 바로 실행시켜주지 않고 JVM에 의해 실행되기 때문에
	JVM으로부터 시스템 자원을 할당받는다.	

쓰레드
	프로세스의 처리 경로
	처리 경로는 디폴트로 한 개이다.
	멀티 쓰레드를 구현할 때에는 스케줄링 작업이 필요하다.

 - 단일 쓰레드
	처리 경로를 한 개만 가지고 있기 때문에 직렬적이다.
	동시에 많은 양을 처리하기 힘들기 때문에 상대적으로 비효율적이다.
	하지만 하나의 작업에 문제가 발생하더라도 다른 작업에는 영향을 끼치지 않는다.
	따라서 안정성이 보장되고 설계 시 멀티 쓰레드에 비해 쉽다.	

- 멀티 쓰레드
	하나의 프로세스를 동시에 처리하는 것처럼 보이지만 사실은 매우 짧은 단위로
	분할해서 차례로 처리한다. 
	여러개의 처리 경로를 가질 수 있도록 하며, 동시 작업이 가능해진다.
	설계하기 굉장히 어려우며, 하나의 쓰레드 문제 발생 시 모든 쓰레드에 문제가
	발생하게 된다.
	JAVA 웹 서버가 대표적인 멀티 쓰레드이다. 멀티 쓰레드로 설계했다면, 
	처리량 증가, 효율셩 증가, 처리비용 감소의 장점이 있기 때문에 단점을 
	감수하고 설계하는 편이다.
----------------------------------------------------------------
멀티 쓰레드 구현 방법
	*핵심 : run() 메소드 재정의, 구현

	1. Thread 클래스 상속
	2. Runnable 인터페이스 지정
----------------------------------------------------------------
[코테 실습(20분 제한)]
	동석이네 동물원에는 3마리의 동물이 있다.	
	각 동물은 울음소리가 다르고 2마리의 동물은 동시에 운다.
	나머지 1마리 동물은 2마리 동물이 모두 울고 나서 마지막에 운다.
	
	package명은 thread.threadTest1로 만들고 클래스는 2개만 선언한다.
	하나의 클래스에는 main 쓰레드가 있다.
	Runnable 인터페이스로 멀티쓰레드를 구현하고 반드시 join()을 사용한다.
	* 각 동물은 10번씩만 운다.

---------------------------------------------------------------------------------------------------------------

동기화(Synchronized)
	하나의 쓰레드가 자원에 접근 중일 때 다른 쓰레드가 동시에 같은 자원을 
	접근하지 못하게 막는 것. 즉, 자원 공유 문제를 해결할 수 있다.
	쓰레드를 제어할 때에도 사용한다.

 -synchronized(mutex){ ... }
	동기화 블럭이라고 부르며, 일부 소스코드만 동기화를 걸어준다.

 -synchronized
	영역 전체에 동기화를 걸어주며, 메소드 리턴타입 앞에 작성하면 
	해당 메소드 전체에 동기화가 걸린다.

Thread 종료 방법
	1. 필드에 boolean타입의 변수를 선언하고, run()안에 있는
	반복문에 해당 변수가 true일 경우 break를 할 수 있도록 설계한다.
	
	2. sleep(), wait(), join()등의 메소드를 통해 쓰레드가 일시정지
	상태가 되면 Thread객체.interrupt()를 사용하여 InterruptedException
	을 발생시킨다.

	3. 쓰레드를 일시정지하는 코드가 없을 경우 Thread.interrupted()의 상태를
	확인한다.
	Thread객체.interrupt()를 사용하면 Thread.interrupted()의 상태는
	true로 변경되거, 민약 Thread.interrupted()를 두 번 사용하면
	두 번째부터는 false 상태로 리턴된다.

	4. System.exit(0)를 사요하면 프로세스 종료(전체 쓰레드 종료).

---------------------------------------------------------------------------------------------------------------

파일 입출력
	Writer(출력)
		BufferedWriter : 버퍼를 사용한 출력 클래스
		FileWriter : 전달한 경로의 파일을 출력하기 위한 목적으로 열어준다.
			     전달한 경로에 파일이 없다면 새롭게 만든 후 열어준다.
		File : 전달한 경로에 있는 파일의 정보를 담는 타입
		       파일의 유무 검사, 파일 삭제, 경로 가져오기 등

	Reader(입력)
		BufferedReader : 버퍼를 사용한 입력 클래스
		FileReader : 전달한 경로의 파일을 입력하기 위한 목적으로 열어준다.
			     전달한 경로에 파일이 없다면 오류가 발생한다.
		File

인코딩
	원본 데이터를 byte로 변환 시킬 때 사용되는 방식
	
	각 간 갇 갈 감 ... 갛 : 완성형
	ㄱ + ㅏ + ㄱ : 조합형

	조합형이 더 효율적이고 대표적인 조합형 인코딩 방식은 UTF-8이다.

---------------------------------------------------------------------------------------------------------------

소프트웨어 디자인 설계 패턴
▶ MVC
	M(model) : DB에서 조회된 결과 값을 담기 위한 변수들이 선언된 클래스
			-클래스명 뒤에 VO, DTO라는 문자를 붙여준다.
			-VO(Value Object)
			-DTO(Data Transfer Object)

	V(view) : 사용자에게 보여질 화면을 구성하는 부분
			- Controller에 선언된 메소드를 사용하는 부분

	C(controller) : DB에 접근할 수 있는 메소드들이 선언된 클래스
			- 접근 후 결과값이 있을 경우 Model 객체에 담은 후 처리
			- 클래스명 뒤에 DAO라는 문자를 붙여준다.
			- DAO(Data Access Object)

---------------------------------------------------------------------------------------------------------------
